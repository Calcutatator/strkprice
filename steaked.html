<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steaked BTC</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            background: #000;
            color: #fff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px 100px;
        }

        main {
            width: 100%;
            max-width: 640px;
        }

        .container {
            text-align: center;
            width: 100%;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        body.ready .container {
            opacity: 1;
            transform: translateY(0);
        }

        .headlines {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            padding: 30px 0 10px;
        }

        .ticker {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.3em;
            opacity: 0.5;
            margin-bottom: 14px;
        }

        .shielded-wrapper {
            display: inline-flex;
            align-items: baseline;
            gap: 12px;
        }

        .shielded-value {
            font-size: clamp(48px, 10vw, 92px);
            font-weight: 200;
            letter-spacing: -0.02em;
        }

        .shielded-suffix {
            font-size: 20px;
            letter-spacing: 0.2em;
            opacity: 0.6;
        }

        .chart-wrapper {
            margin-top: 32px;
        }

        .circle-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px 0 0;
        }

        .circle-graph {
            position: relative;
            width: clamp(40px, 12vw, 70px);
            height: clamp(40px, 12vw, 70px);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.85) 40%, rgba(255, 255, 255, 0.18) 95%);
            border: 1px solid rgba(255, 255, 255, 0.65);
            box-shadow: 0 0 90px rgba(255, 255, 255, 0.35), inset 0 0 80px rgba(255, 255, 255, 0.45);
            transition: transform 0.8s ease;
        }

        .circle-graph::before {
            content: '';
            position: absolute;
            inset: -18%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.55), transparent 50%);
            filter: blur(10px);
            opacity: 0.75;
            z-index: -1;
        }

        .circle-graph::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            opacity: 0;
        }

        .view-toggle {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translate(-50%, 20px);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 100px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.02em;
            text-decoration: none;
            transition: opacity 0.3s ease, transform 0.4s ease, border-color 0.2s ease, color 0.2s ease;
            opacity: 0;
        }

        body.ready .view-toggle {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        .view-toggle:hover {
            border-color: rgba(255, 255, 255, 0.45);
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.05);
        }

        .view-toggle:active {
            transform: translate(-50%, 0) scale(0.98);
        }

        .toggle-arrow {
            width: 14px;
            height: 14px;
            transition: transform 0.3s ease;
        }

        .circle-graph--up {
            animation: pulseExpand 0.9s ease;
        }

        .circle-graph--up::after {
            animation: ripple 1s ease-out;
        }

        .circle-graph--down {
            animation: pulseContract 1s ease;
        }

        .circle-graph--ambient {
            animation: ambientPulse 1.2s ease-in-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0.9);
                opacity: 0.2;
            }
            60% {
                transform: scale(1.2);
                opacity: 0.05;
            }
            100% {
                transform: scale(1.35);
                opacity: 0;
            }
        }

        @keyframes pulseExpand {
            0% { transform: scale(1); }
            45% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255, 255, 255, 0.16), inset 0 0 50px rgba(255, 255, 255, 0.12); }
            100% { transform: scale(1); }
        }

        @keyframes pulseContract {
            0% { transform: scale(1); }
            40% { transform: scale(0.9); box-shadow: 0 0 30px rgba(255, 255, 255, 0.04), inset 0 0 10px rgba(255, 255, 255, 0.04); }
            100% { transform: scale(1); }
        }

        @keyframes ambientPulse {
            0% { transform: scale(1); box-shadow: 0 0 90px rgba(255, 255, 255, 0.35), inset 0 0 80px rgba(255, 255, 255, 0.45); }
            50% { transform: scale(1.025); box-shadow: 0 0 80px rgba(255, 255, 255, 0.45), inset 0 0 90px rgba(255, 255, 255, 0.55); }
            100% { transform: scale(1); box-shadow: 0 0 90px rgba(255, 255, 255, 0.35), inset 0 0 80px rgba(255, 255, 255, 0.45); }
        }

        @media (max-width: 640px) {
            body {
                padding-bottom: 120px;
            }
        }
    </style>
</head>
<body>
    <main>
        <div class="container">
            <div class="headlines">
                <div class="ticker">Bitcoin TVL</div>
                <div class="shielded-wrapper">
                    <span class="shielded-value" id="shielded-value">--</span>
                    <span class="shielded-suffix">BTC</span>
                </div>
            </div>

            <div class="chart-wrapper">
                <div class="circle-wrapper">
                    <div class="circle-graph" id="btc-circle"></div>
                </div>
            </div>
        </div>
    </main>
    <a class="view-toggle" href="index.html">
        <span class="toggle-text">STRK</span>
        <svg class="toggle-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M7 17L17 7M17 7H7M17 7V17" />
        </svg>
    </a>

    <script>
        const CHAIN_ASSETS_URL = 'https://api.llama.fi/chainAssets';
        const BTC_PRICE_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd';
        const BTC_SYMBOL_PATTERN = /btc/i;
        const POLL_INTERVAL = 5 * 60 * 1000;

        let pollTimer = null;
        let ambientTimer = null;
        let lastBtcValue = null;

        const valueEl = document.getElementById('shielded-value');
        const circleEl = document.getElementById('btc-circle');

        const triggerCircleAnimation = (direction) => {
            if (!circleEl) return;
            circleEl.classList.remove('circle-graph--up', 'circle-graph--down', 'circle-graph--ambient');
            // Force reflow so repeated animations retrigger
            void circleEl.offsetWidth;
            if (direction === 'up') {
                circleEl.classList.add('circle-graph--up');
            } else if (direction === 'down') {
                circleEl.classList.add('circle-graph--down');
            } else if (direction === 'ambient') {
                circleEl.classList.add('circle-graph--ambient');
            }
        };

        if (circleEl) {
            circleEl.addEventListener('animationend', () => {
                circleEl.classList.remove('circle-graph--up', 'circle-graph--down', 'circle-graph--ambient');
            });
        }

        const scheduleAmbientPulse = () => {
            if (!circleEl) return;
            const interval = 2500 + Math.random() * 3500;
            ambientTimer = setTimeout(() => {
                triggerCircleAnimation('ambient');
                scheduleAmbientPulse();
            }, interval);
        };

        const formatBtc = (value) => {
            if (!isFinite(value)) return '--';
            if (value >= 1000) {
                return value.toLocaleString('en-US', { maximumFractionDigits: 0 });
            }
            if (value >= 1) {
                return value.toLocaleString('en-US', { maximumFractionDigits: 2 });
            }
            return value.toLocaleString('en-US', { maximumFractionDigits: 4 });
        };

        const updateHeadline = (btcValue) => {
            valueEl.textContent = formatBtc(btcValue);
            document.title = `${formatBtc(btcValue)} BTC Â· Steaked`;

            if (typeof lastBtcValue === 'number') {
                if (btcValue > lastBtcValue + 1e-8) {
                    triggerCircleAnimation('up');
                } else if (btcValue < lastBtcValue - 1e-8) {
                    triggerCircleAnimation('down');
                }
            }
            lastBtcValue = btcValue;
        };

        const sumStarknetBtcUsd = (payload) => {
            const breakdown = payload?.Starknet?.canonical?.breakdown;
            if (!breakdown) return 0;
            return Object.entries(breakdown).reduce((total, [symbol, value]) => {
                if (!BTC_SYMBOL_PATTERN.test(symbol)) return total;
                const numeric = typeof value === 'string' ? parseFloat(value) : Number(value);
                return total + (Number.isFinite(numeric) ? numeric : 0);
            }, 0);
        };

        const fetchStatsSnapshot = async () => {
            const [assetsRes, priceRes] = await Promise.all([
                fetch(CHAIN_ASSETS_URL),
                fetch(BTC_PRICE_URL)
            ]);

            if (!assetsRes.ok) {
                throw new Error('Unable to fetch Starknet chain assets');
            }

            if (!priceRes.ok) {
                throw new Error('Unable to fetch BTC price');
            }

            const assetsPayload = await assetsRes.json();
            const btcUsdTotal = sumStarknetBtcUsd(assetsPayload);
            if (!btcUsdTotal) {
                throw new Error('BTC breakdown missing for Starknet');
            }

            const pricePayload = await priceRes.json();
            const spotPrice = pricePayload?.bitcoin?.usd ?? null;
            if (!spotPrice) {
                throw new Error('BTC price unavailable');
            }

            return btcUsdTotal / spotPrice;
        };

        const refreshData = async () => {
            try {
                const btcValue = await fetchStatsSnapshot();
                updateHeadline(btcValue);
            } catch (error) {
                console.error('Failed to load BTC snapshot', error);
                valueEl.textContent = '--';
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            refreshData();
            pollTimer = setInterval(refreshData, POLL_INTERVAL);
            scheduleAmbientPulse();

            requestAnimationFrame(() => {
                document.body.classList.add('ready');
            });
        });

        window.addEventListener('beforeunload', () => {
            if (pollTimer) {
                clearInterval(pollTimer);
            }
            if (ambientTimer) {
                clearTimeout(ambientTimer);
            }
        });
    </script>
</body>
</html>
